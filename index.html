<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>GALAXY WAR - PVP FINAL</title>
    <link rel="shortcut icon" href="#">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; }
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: #00ffcc; font-family: 'Consolas', monospace;
            background: rgba(20, 0, 0, 0.9); /* Fundo avermelhado de combate */
            padding: 15px; border: 2px solid #ff0000; border-radius: 8px;
            pointer-events: none; user-select: none; width: 250px; z-index: 10;
        }
        #blocker {
            position: absolute; width: 100%; height: 100%;
            background: linear-gradient(135deg, #000000, #220000);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; font-family: sans-serif; z-index: 999; cursor: pointer;
            text-align: center;
        }
        h1 { margin: 0; font-size: 3em; color: #ff3300; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 20px red;}
        .blink { animation: pulse 0.5s infinite alternate; color: #fff; margin-top: 20px; font-weight: bold;}
        @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }
        
        .bar-container { width: 100%; background: #222; height: 15px; margin-top: 5px; border: 1px solid #555; }
        .bar { height: 100%; width: 100%; transition: width 0.1s; }
        
        #player-count { color: cyan; font-weight: bold; font-size: 1.2em; }
        
        #msg-base { 
            position: absolute; bottom: 20%; width: 100%; text-align: center;
            color: #ffff00; font-size: 30px; font-weight: bold; text-shadow: 0 0 20px yellow;
            display: none; pointer-events: none;
        }
        #rescue-ui {
            position: absolute; top: 40%; width: 100%; text-align: center; 
            color: yellow; font-size: 20px; font-family: sans-serif; font-weight: bold;
            text-shadow: 0 0 5px red; display: none; pointer-events: none;
            animation: pulse 0.5s infinite;
        }
        #msg-hit {
            position: absolute; top: 30%; width: 100%; text-align: center;
            color: red; font-size: 50px; font-weight: bold; text-shadow: 0 0 20px red;
            display: none; pointer-events: none;
        }
        
        #glide-ind { color: cyan; font-weight: bold; display: none; margin-top: 5px; text-shadow: 0 0 5px cyan; }
        #damage-overlay {
            position: absolute; width: 100%; height: 100%; pointer-events: none;
            box-shadow: inset 0 0 0 0 red; transition: box-shadow 0.1s; z-index: 5;
        }
    </style>
</head>
<body>
    <div id="damage-overlay"></div>
    <div id="blocker">
        <h1>GALAXY WAR PVP</h1>
        <p>Destrua os outros jogadores!</p>
        <div class="blink">[ CLIQUE PARA COMBATE ]</div>
    </div>

    <div id="hud">
        STATUS DE COMBATE<br>
        ---------------<br>
        COMBUSTÍVEL: <span id="fuel-txt">100%</span>
        <div class="bar-container"><div id="fuel-bar" class="bar" style="background: orange;"></div></div>
        <br>
        LASER: <span id="laser-txt">PRONTO</span>
        <div class="bar-container"><div id="laser-bar" class="bar" style="background: cyan;"></div></div>
        <br>
        JOGADORES: <span id="player-count">Off</span><br>
        ZONA: <span id="atmos-txt">TERRA</span>
        <div id="glide-ind">✈ PLANANDO</div>
    </div>

    <div id="msg-base">⚡ REABASTECENDO ⚡</div>
    <div id="rescue-ui">⚠ PANE SECA! AGUARDANDO EQUIPE...</div>
    <div id="msg-hit">VOCÊ MORREU!</div>

    <script src="/socket.io/socket.io.js"></script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- SISTEMA ONLINE ---
        let socket;
        let isOnline = false;
        const otherPlayers = {}; 

        try {
            socket = io();
            isOnline = true;
        } catch(e) { console.log("Offline"); }

        // --- AUDIO 8-BIT ---
        const audioSys = {
            ctx: null, isInit: false, engineGain: null, melodyInterval: null, noteIndex: 0,
            melody: [ 261.63, 0, 329.63, 0, 392.00, 0, 493.88, 0, 523.25, 0, 392.00, 0, 329.63, 0, 261.63, 0 ],
            init: function() {
                if(this.isInit) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                
                // Motor (Ruído Branco 8-bit)
                const bSize = this.ctx.sampleRate * 2;
                const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource(); noise.buffer=buf; noise.loop=true;
                const filter = this.ctx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=600;
                this.engineGain = this.ctx.createGain(); this.engineGain.gain.value=0;
                noise.connect(filter); filter.connect(this.engineGain); this.engineGain.connect(this.ctx.destination);
                noise.start();

                // Música
                setInterval(() => {
                    const freq = this.melody[this.noteIndex];
                    if(freq > 0) this.playBeep(freq);
                    this.noteIndex = (this.noteIndex + 1) % this.melody.length;
                }, 200);
                this.isInit = true;
            },
            playBeep: function(freq) {
                if(!this.ctx) return;
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type='square'; o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(0.02, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+0.1);
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+0.1);
            },
            updateEngine: function(isThrusting) {
                if(!this.isInit) return;
                this.engineGain.gain.setTargetAtTime(isThrusting ? 0.2 : 0, this.ctx.currentTime, 0.1);
            },
            shoot: function() {
                if(!this.isInit) return;
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type='square'; o.frequency.setValueAtTime(600, this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime+0.15);
                g.gain.setValueAtTime(0.05, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+0.15);
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+0.2);
            },
            explode: function() {
                if(!this.isInit) return;
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type='sawtooth'; o.frequency.value=50; 
                g.gain.setValueAtTime(0.2, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+0.5);
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+0.5);
            }
        };

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x888888, 2));
        const sun = new THREE.DirectionalLight(0xffffff, 1.5); sun.position.set(50, 100, 50); scene.add(sun);

        // --- MAPA ---
        const worldSize = 128;
        const earth = new THREE.Mesh(new THREE.PlaneGeometry(worldSize, worldSize), new THREE.MeshPhongMaterial({color: 0x225522}));
        earth.rotation.x = -Math.PI/2; scene.add(earth);
        const alien = new THREE.Mesh(new THREE.PlaneGeometry(worldSize, worldSize), new THREE.MeshPhongMaterial({color: 0x550055}));
        alien.rotation.x = Math.PI/2; alien.position.y = worldSize; scene.add(alien);
        
        // Bases Amarelas
        const padMat = new THREE.MeshBasicMaterial({color: 0xffff00});
        const pad1 = new THREE.Mesh(new THREE.PlaneGeometry(25,25), padMat); pad1.rotation.x = -Math.PI/2; pad1.position.y = 0.2; scene.add(pad1);
        const pad2 = new THREE.Mesh(new THREE.PlaneGeometry(25,25), padMat); pad2.rotation.x = Math.PI/2; pad2.position.y = 127.8; scene.add(pad2);
        
        const grid = new THREE.GridHelper(worldSize, 8, 0x555555, 0x111111); grid.position.y = 64; scene.add(grid);

        const sGeo = new THREE.BufferGeometry(); const sPos = [];
        for(let i=0; i<3000; i++) sPos.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*800);
        sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
        scene.add(new THREE.Points(sGeo, new THREE.PointsMaterial({color:0xffffff, size:0.7})));

        // Arvores Terra
        const targets = [];
        const treeGeo = new THREE.ConeGeometry(2, 6, 5); const treeMat = new THREE.MeshPhongMaterial({color: 0x00ff00});
        for(let i=0;i<20;i++) { 
            const t = new THREE.Mesh(treeGeo, treeMat); 
            t.position.set((Math.random()-0.5)*100, 3, (Math.random()-0.5)*100); 
            if(t.position.distanceTo(new THREE.Vector3(0,0,0))>15) { scene.add(t); targets.push(t); }
        }
        // Arvores Alien (No Teto)
        const alienTreeGeo = new THREE.ConeGeometry(1, 12, 6); const alienTreeMat = new THREE.MeshPhongMaterial({color: 0x00ffff});
        for(let i=0; i<25; i++) {
            const at = new THREE.Mesh(alienTreeGeo, alienTreeMat);
            at.position.set((Math.random()-0.5)*110, 125, (Math.random()-0.5)*110);
            at.rotation.z = Math.PI; 
            if(at.position.distanceTo(new THREE.Vector3(0,128,0)) > 15) { scene.add(at); targets.push(at); }
        }

        // --- NAVE ---
        const ship = new THREE.Group(); ship.position.set(0, 5, 0); scene.add(ship);

        function createShipMesh(color) {
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 5), new THREE.MeshPhongMaterial({color: 0x888888})));
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.75, 2.5, 4), new THREE.MeshPhongMaterial({color: color}));
            nose.rotation.x = Math.PI/2; nose.rotation.y = Math.PI/4; nose.position.z = 3.75; g.add(nose);
            const wing = new THREE.Mesh(new THREE.BoxGeometry(8, 0.2, 3), new THREE.MeshPhongMaterial({color: 0x666666}));
            wing.position.set(0, 0, -0.5); g.add(wing);
            const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 1, 16), new THREE.MeshStandardMaterial({color: 0x222222}));
            engine.rotation.x = Math.PI/2; engine.position.z = -2.6; g.add(engine);
            return g;
        }
        const localMesh = createShipMesh(0x00ffcc); ship.add(localMesh);

        // --- SISTEMA ONLINE + PVP ---
        if(isOnline) {
            socket.on('currentPlayers', (players) => {
                Object.keys(players).forEach((id) => { if (id !== socket.id) addOtherPlayer(id, players[id]); });
                updateCount();
            });
            socket.on('newPlayer', (data) => { addOtherPlayer(data.id, data.player); updateCount(); });
            socket.on('playerMoved', (data) => {
                if(otherPlayers[data.id]) {
                    otherPlayers[data.id].position.set(data.x, data.y, data.z);
                    otherPlayers[data.id].quaternion.set(data.qx, data.qy, data.qz, data.qw);
                }
            });
            socket.on('playerDisconnected', (id) => {
                if (otherPlayers[id]) { scene.remove(otherPlayers[id]); delete otherPlayers[id]; updateCount(); }
            });
            
            // MORTE
            socket.on('youDied', () => {
                // Flash vermelho
                document.getElementById('damage-overlay').style.boxShadow = "inset 0 0 100px 50px red";
                setTimeout(() => document.getElementById('damage-overlay').style.boxShadow = "none", 500);
                
                // Som e Msg
                document.getElementById('msg-hit').style.display = 'block';
                audioSys.explode();

                // Respawn
                fuel = 100;
                ship.position.set(0, 5, 0); // Volta pra base
                ship.rotation.set(0,0,0);
                speed = 0;

                setTimeout(() => document.getElementById('msg-hit').style.display = 'none', 3000);
            });
        }
        function addOtherPlayer(id, data) {
            const other = createShipMesh(data.color);
            other.position.set(data.x, data.y, data.z); scene.add(other); otherPlayers[id] = other;
        }
        function updateCount() { document.getElementById('player-count').innerText = Object.keys(otherPlayers).length + 1; }

        // --- FOGO (RASTRO FINO E LONGO) ---
        const particles = [];
        const pGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2); // Fino
        const pMat = new THREE.MeshBasicMaterial({color: 0xffff00, transparent: true, opacity: 1});

        function spawnFire() {
            const p = new THREE.Mesh(pGeo, pMat.clone());
            ship.updateMatrixWorld(); 
            const spawnPos = new THREE.Vector3(0, 0, -3.5); spawnPos.applyMatrix4(ship.matrixWorld); 
            p.position.copy(spawnPos);
            const backDir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
            p.userData = { life: 3.0, vel: backDir.multiplyScalar(-0.05).add(new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02)) };
            scene.add(p); particles.push(p);
        }

        // --- RESGATE ---
        let rescueTimer = 0; let isRescuing = false; let crewMembers = [];
        function spawnCrew(world) {
            const startY = (world === 'terra') ? 0.5 : 127.5;
            const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6); const mat = new THREE.MeshBasicMaterial({color: 0xffff00}); 
            for(let i=0; i<4; i++) {
                const c = new THREE.Mesh(geo, mat);
                const origin = new THREE.Vector3((Math.random()-0.5)*2, startY, (Math.random()-0.5)*2);
                c.position.copy(origin);
                c.userData = { state: 'to_ship', origin: origin.clone() };
                scene.add(c); crewMembers.push(c);
            }
        }
        function updateCrew() {
            if(crewMembers.length === 0) return;
            for(let i=crewMembers.length-1; i>=0; i--) {
                const c = crewMembers[i];
                let target = (c.userData.state === 'to_ship') ? ship.position.clone() : c.userData.origin.clone();
                const dir = new THREE.Vector3().subVectors(target, c.position); dir.y = 0; 
                if(dir.length() > 1) { dir.normalize().multiplyScalar(0.2); c.position.add(dir); c.rotation.y += 0.3; } 
                else {
                    if(c.userData.state === 'to_ship') {
                        fuel = 100; document.getElementById('rescue-ui').innerText = "ABASTECIDO! EQUIPE RETORNANDO..."; c.userData.state = 'returning';
                    } else {
                        scene.remove(c); crewMembers.splice(i, 1);
                        if(crewMembers.length === 0) { document.getElementById('rescue-ui').style.display = 'none'; isRescuing = false; rescueTimer = 0; }
                    }
                }
            }
        }

        // --- LOOP ---
        const keys = { w:false, s:false, a:false, d:false, q:false, e:false, space:false };
        let speed = 0, fuel = 100, isLocked = false, shotCooldown = 0;
        let camTheta = Math.PI, camPhi = Math.PI/3, camRadius = 50; 
        const bullets = [];

        document.addEventListener('mousemove', e => {
            if(!isLocked) return;
            const invert = (ship.position.y > 64) ? -1 : 1;
            camTheta -= e.movementX * 0.002 * invert;
            camPhi -= e.movementY * 0.002;
            camPhi = Math.max(0.1, Math.min(Math.PI-0.1, camPhi));
        });
        document.addEventListener('mousedown', () => { 
            if(isLocked && shotCooldown <= 0) {
                audioSys.shoot(); shotCooldown = 300;
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({color:0x00ffff}));
                b.position.copy(ship.position);
                b.userData = { vel: new THREE.Vector3(0,0,1).applyQuaternion(ship.quaternion).normalize(), life: 100 };
                scene.add(b); bullets.push(b);
            }
        });
        document.getElementById('blocker').addEventListener('click', () => { document.body.requestPointerLock(); audioSys.init(); });
        document.addEventListener('pointerlockchange', () => { isLocked = (document.pointerLockElement === document.body); document.getElementById('blocker').style.display = isLocked ? 'none' : 'flex'; });
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true); window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('keydown', e => { if(e.code === 'Space') keys.space = true; }); window.addEventListener('keyup', e => { if(e.code === 'Space') keys.space = false; });

        function animate() {
            requestAnimationFrame(animate);
            if(!isLocked) return;

            // Movimento
            if(keys.w) ship.rotateX(0.015); if(keys.s) ship.rotateX(-0.015);
            if(keys.a) ship.rotateY(0.02); if(keys.d) ship.rotateY(-0.02);
            if(keys.q) ship.rotateZ(-0.03); if(keys.e) ship.rotateZ(0.03);

            const isThrusting = keys.space && fuel > 0;
            if(isThrusting) { speed += 0.005; fuel -= 0.1; spawnFire(); } else { speed *= 0.995; }
            if(speed > 0.25) speed = 0.25;
            
            ship.translateZ(speed);
            audioSys.updateEngine(isThrusting);

            // Gravidade e Atmosfera
            const y = ship.position.y;
            const topWorld = y > 64;
            
            if (y < 40) { renderer.setClearColor(0x005599); scene.fog.density = 0; document.getElementById('atmos-txt').innerText="TERRA"; }
            else if (y >= 40 && y <= 88) { renderer.setClearColor(0x000000); scene.fog.color.setHex(0x000000); scene.fog.density = 0.005; document.getElementById('atmos-txt').innerText="ESPAÇO"; }
            else { renderer.setClearColor(0x770077); scene.fog.density = 0; document.getElementById('atmos-txt').innerText="ALIEN"; }

            // Gravidade PESADA (0.025)
            let baseG = 0.025; let lift = speed * 0.12; 
            let gravity = Math.max(0, baseG - lift);
            if(y > 40 && y < 88) gravity = 0;
            document.getElementById('glide-ind').style.display = (gravity < 0.01 && speed > 0.05) ? 'block' : 'none';

            if(!topWorld) { ship.position.y -= gravity; camera.up.set(0, 1, 0); } else { ship.position.y += gravity; camera.up.set(0, -1, 0); }
            if(ship.position.y < 2) ship.position.y = 2; if(ship.position.y > 126) ship.position.y = 126;
            if(Math.abs(ship.position.x) > 64) ship.position.x = Math.sign(ship.position.x)*64; if(Math.abs(ship.position.z) > 64) ship.position.z = Math.sign(ship.position.z)*64;

            // Abastecimento
            const dist = Math.sqrt(ship.position.x**2 + ship.position.z**2);
            const onBase = (dist < 15) && ((!topWorld && y < 8) || (topWorld && y > 120));
            const msg = document.getElementById('msg-base');
            if(onBase && speed < 0.1) {
                 if(fuel < 100) { fuel = Math.min(100, fuel + 0.5); msg.style.display = 'block'; shotCooldown = 0; } 
                 else { msg.style.display = 'none'; }
            } else { msg.style.display = 'none'; }

            // Rede
            if(isOnline && socket) {
                socket.emit('playerMovement', { x: ship.position.x, y: ship.position.y, z: ship.position.z, qx: ship.quaternion.x, qy: ship.quaternion.y, qz: ship.quaternion.z, qw: ship.quaternion.w });
            }

            // Resgate
            if(fuel <= 0 && speed < 0.01 && (ship.position.y < 3 || ship.position.y > 125)) {
                if(!isRescuing) {
                    rescueTimer++;
                    document.getElementById('rescue-ui').style.display = 'block';
                    if(rescueTimer > 300 && crewMembers.length === 0) { isRescuing = true; spawnCrew(!topWorld?'terra':'alien'); }
                }
            } else { if(!isRescuing) { rescueTimer = 0; document.getElementById('rescue-ui').style.display = 'none'; } }
            updateCrew();

            // Particulas
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i]; p.position.add(p.userData.vel); p.userData.life -= 0.01; 
                p.material.opacity = Math.min(1, p.userData.life);
                if(p.userData.life <= 0) { scene.remove(p); p.material.dispose(); particles.splice(i,1); }
            }

            // --- BALAS (COLISÃO PVP) ---
            if(shotCooldown > 0) shotCooldown--;
            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i]; b.position.add(b.userData.vel); b.userData.life--;
                let hit = false;
                
                // 1. Colisão Props
                for(let j=targets.length-1; j>=0; j--) { 
                    if(b.position.distanceTo(targets[j].position)<5) { scene.remove(targets[j]); targets.splice(j,1); hit=true; } 
                }
                
                // 2. Colisão PVP (Só se estiver online)
                if(isOnline && !hit) {
                    Object.keys(otherPlayers).forEach(id => {
                        const enemy = otherPlayers[id];
                        if(b.position.distanceTo(enemy.position) < 3) {
                            socket.emit('playerHit', id); // MATA INIMIGO
                            hit = true;
                            audioSys.shoot();
                        }
                    });
                }

                if(b.userData.life <= 0 || hit) { scene.remove(b); bullets.splice(i, 1); }
            }

            const cx = ship.position.x + camRadius * Math.sin(camPhi) * Math.sin(camTheta);
            const cy = ship.position.y + camRadius * Math.cos(camPhi);
            const cz = ship.position.z + camRadius * Math.sin(camPhi) * Math.cos(camTheta);
            camera.position.set(cx, cy, cz); camera.lookAt(ship.position);

            document.getElementById('fuel-bar').style.width = fuel + '%';
            renderer.render(scene, camera);
        }

        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>

